//Menu:[NWalign]
//Create Needleman alignment traceback matrix(same as the matrix generated by dynamic programming).It executes with high speed and low space occupation.It is faster than common dynamic programming
//Take 2 values."_arr1"/"_arr2" AA or AAid sequence (nucleotide compatible,<type> can be char or int)
//Return darray<int> Needleman alignment traceback matrix
template<class type>
void NWalign(sarray<type> & _arr1,sarray<type> & _arr2,darray<int> & BKMATX)
{
	int row=_arr1.size(),col=_arr2.size(),tmpsc,max,s;
	BKMATX.fast_resize(row+1,col+1,0);                          //BKMATX is a background matrix store the max match information.
	for(int j=col-1;j>=0;--j)
	{
		for(int i=row-1;i>=0;--i)
	    {		
			tmpsc=(_arr1[i]==_arr2[j]?1:0);
			s=tmpsc+BKMATX(i+1,j+1);                         
		    max=(BKMATX(i+1,j)>BKMATX(i,j+1)?BKMATX(i+1,j):BKMATX(i,j+1));
			BKMATX(i,j)=(s>max?s:max);
		} 
	}
	return;
}

//a structure pass parameters to thread function 
template <class type>
struct getwpstr
{	vector<darray<int> >* BKMATXvec;
	vector<sarray<int> >* seqdb;
	vector<darray<type> >* scmatxvec;
	darray<double>* distmatx;
	int gappnt;
	vector<darray<int> >* alnmatxvec;
	sarray<type>* alnscore;
	char st;
	int scmatxid;
	darray<int>* ttm;
	int thrdid;
};

//thread function
template <class type>
void *THNWwp(void* param)
{	
	getwpstr<type>* dtstr=static_cast<getwpstr<type>*>(param);

	int thrdid=dtstr->thrdid;
	int start,end,size,quantum,I,J;                 //"start""end"thread task start and end position."quantum" aliquot of task
        size=dtstr->ttm->getcnum();
        quantum=(int)((double)size/CPUNUM);
        if(quantum<1)                           //if CPU number is larger than task number,set "quantum" to 1,otherwise it is 0.
                quantum=1;
        start=thrdid*quantum;
        if(thrdid!=CPUNUM-1)
        end=(thrdid+1)*quantum-1;
        else
                end=size-1;
	if(end>=size)
		return NULL;

	int dist=dtstr->scmatxid;
	for(int i=start;i<=end;++i)
	{
		I=dtstr->ttm->operator()(0,i);
		J=dtstr->ttm->operator()(1,i);
		if(dtstr->st!='f') 
			dist=(int)(dtstr->distmatx->operator()(I,J)*100);
		NWwp(dtstr->BKMATXvec->operator[](i),dtstr->seqdb->operator[](I),dtstr->seqdb->operator[](J),dtstr->scmatxvec->operator[](dist),dtstr->gappnt,dtstr->alnmatxvec->operator[](i),dtstr->alnscore->operator[](i));
	}
}

//take 5 values. "_BKMATXvec" a vector of BKMATX generated by NWalign."_seqdb" vector of sequences."_scmatxvec" a vector of scoring matrix."_distmatx" pairwise distance matrix."_gappnt" gap penalty."_st" fix scoring matrix or use dynamic.
template<class type>
void NWwp(vector<darray<int> > & _BKMATXvec,vector<sarray<int> > & _seqdb, vector<darray<type> > & _scmatxvec, darray<double> & _distmatx, const int & _gappnt, vector<darray<int> > & alnmatxvec, sarray<type> & alnscore, char _st='f', const int & _scmatxid=250)
{
	int size=_BKMATXvec.size();
	alnmatxvec.resize(size);
	alnscore.resize(size);
	darray<int> ttm=generatethreadid(_seqdb.size());
	vector<getwpstr<type> > dtstr(CPUNUM);
	pthread_t threads[CPUNUM];
	int code=0;
	for(int i=0;i<CPUNUM;++i)
	{	dtstr[i]={&_BKMATXvec,&_seqdb,&_scmatxvec,&_distmatx,_gappnt,&alnmatxvec,&alnscore,_st,_scmatxid,&ttm,i};
		code=pthread_create(&threads[i],NULL,THNWwp<type>,(void*)&dtstr[i]);	//THNWwp<type> is necessary for template
		if(code != 0)
		{	cout<<"Thread number exceeded system limit. You are running "<<CPUNUM<<" CPUs. Change to a smaller number with -c option"<<endl;
			exit(0);
		}
	}
	for(int i=0;i<CPUNUM;++i)
		pthread_join(threads[i],NULL);
}

//Menu:[NWalign]-[NWwp]
//This function is exclusively used to trace the waypoint of alignment matrix generated by NWalign function(Dynamic pogramming algorithm).
template<class type>
void NWwp(darray<int> & _BKMATX,sarray<int> & _arr1,sarray<int> & _arr2,darray<type> &_scmatx,const type & _gappnt,darray<int> & alnmatx,type & alnscore)
{
	int i=0,j=0,I,J,markI,markJ,gap,start,row=_arr1.size(),col=_arr2.size();
	alnscore=(type)0;
	type maxsc,tmpsc;
	alnmatx.fast_resize(row,col,0);
	darray<int> mwp=_BKMATX.maxwaypoint(0,0);
	i=mwp(mwp._row-1,0);		
	j=mwp(mwp._row-1,1);		//find an optimal start point
	while(i<row && j<col)
	{
		start=_BKMATX(i,j);
		maxsc=(type)INT_MIN;
		markI=i;markJ=j;
		if(_BKMATX(i+1,j+1)!=start)	
		{
			J=j;
			while(J<col && _BKMATX(i,J)==start)
			{
			   if((tmpsc=_scmatx(_arr1[i],_arr2[J])+(J-j)*_gappnt)>maxsc)
			   {
				   markJ=J;
				   gap=markJ-j;
				   maxsc=tmpsc;
			   }
			   J+=1;
		  	}
		   	I=i+1;
		   	while(I<row && _BKMATX(I,j)==start)
		   	{
			   if((tmpsc=_scmatx(_arr1[I],_arr2[j])+(I-i)*_gappnt)>maxsc || (tmpsc==maxsc && (I-i)<gap))
			   {
				   markJ=j;
				   markI=I;
				   gap=I-i;
				   maxsc=tmpsc;
			   }
			   I+=1;
		   	}
		}
		else
			maxsc=_scmatx(_arr1[markI],_arr2[markJ]);
	   	if(maxsc==(type)INT_MIN)
			alnscore+=_scmatx(_arr1[markI],_arr2[markJ]);
	   	else
			alnscore+=maxsc;
		alnmatx(markI,markJ)=1;
		i=markI+1;j=markJ+1;
	}
}
